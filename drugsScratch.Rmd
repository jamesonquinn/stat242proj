---
title: "drugs"
author: "Jameson Quinn"
date: "April 28, 2015"
output: html_document
---

HIHIHIHIH

```{r}
library(data.table)
library(ggplot2)
library(boot)
library(nsprcomp)
library(plyr)
library(pheatmap)
library(matrixStats)
library(reshape2)

load ("gene_to_geneset_matrix.Rdat")
load ("small_CTD1.Rdat")
load ("small_scaled_micro_array_2.Rdat")

#make a function to standardize a vector, then apply it to all the columns of drugs and rna
standardize = function(v) {(v-mean(v))/sd(v)}
drugs = data.table(t(aaply(small_CTD1[!is.na(small_scaled_micro_array_2[,1]),],2,standardize)))
genesets = data.table(gene_to_geneset_matrix)
rna = data.table(t(aaply(small_scaled_micro_array_2[!is.na(small_scaled_micro_array_2[,1]),],2,standardize)))

ndim = 4 # how many PCA dimensions to look at

#do some exploration of alpha factor (upweighting drug variances so that they aren't swamped by the more-numerous RNA data)... commented out
if (F) {
  for (alpha in 2+((0:4)*0.25)) {
    alldat = cbind(rna,alpha*drugs)
    pca = nsprcomp(alldat,ndim,k=rep(200,ndim))
    loads = pca$rotation
    cat(alpha, aaply(loads[1:dim(rna)[2],],2,function(v){sum(v != 0)}),"\n")
  
  }
}

#OK, we've picked an alpha
alpha = 3

#combined data matrix
alldat = cbind(rna,alpha*drugs)
cols = c(names(alldat)) #the names of genes and drugs, for later use

#make a function to make a column of "cancer type" using the last word of the row names of rna
lastPart = Vectorize(function(s){tail(strsplit(s,split="_")[[1]],1)})
alldat[,cancerType:=as.factor(lastPart(rownames(small_CTD1[!is.na(small_scaled_micro_array_2[,1]),])))]

#copy the data matrix so we can get means, as a way towards looking at within- vs. between-group variance (group=cancer type)
admeans = data.table(alldat)
admeans[,(cols):=lapply(.SD,mean),.SDcols=cols, by=cancerType] #now admeans is the all-data-means
adwithin = as.matrix(alldat[,-(length(cols) + 1),with=FALSE]) - as.matrix(admeans[,-(length(cols) + 1),with=FALSE]) #adwithin has within-group variability for all data


pca = nsprcomp(adwithin,ndim,k=rep(200,ndim)) #let's do one to check
loads = pca$rotation #these are the sparse PCA loading factors
cat(alpha, aaply(loads[1:dim(rna)[2],],2,function(v){sum(v != 0)}),"\n") #how many of the 200 loading factors relate to genes, as opposed to drugs, for each dimension?

#Now, put drugs into the geneset matrix. Each drug is a set of 1.
allsets = cbind(genesets,matrix(0,dim(genesets)[1],dim(drugs)[2]))
allsets = as.matrix(rbind(allsets,cbind(matrix(0,dim(drugs)[2],dim(genesets)[2]),diag(dim(drugs)[2]))))

#a function to find what portion of the possible loadings a dimension has in each geneset or drug. Returns a matrix (genes,drugs) x (dimensions). That matrix can be self-multiplied to get overlap factors.
numLoads = function(dat) {
  d = ifelse(dat != 0, 1,0)
  
  aaply(seq(dim(allsets)[1]),1,function(i){colSums(d * allsets[i,] / sum(allsets[i,]))})
}

#now apply the function and get the overlaps
nl = numLoads(loads)
overlaps = nl %*% t(nl)

#melt it so we can ggplot it.
overlapss = melt(overlaps)
setnames(overlapss,c("i","j","value"))
ggplot(overlapss, aes(i,j,fill=value)) + geom_raster()

#OK, now it's time to bootstrap. Set parameters.
minNumLoads = 180 #each boostrap has a random number of loadings per dimension, uniformly...
maxNumLoads = 220 #...between the above and this.

#create a function to pass to boot. Note that boot flattens the "overlap" matrix into vectors, so it will fit in rows of the "t" matrix it returns
getOverlap = function(dat,...) {
  
  pca = nsprcomp(adwithin,ndim,k=rep(sample(minNumLoads:maxNumLoads,1),ndim))
  loads = pca$rotation
  nl = numLoads(loads)
  overlaps = nl %*% t(nl)
  print(rbinom(1,1,.5))
  return(overlaps)
}

r = 100 #how many bootstrap samples. They take a few seconds each.
aboot = boot(adwithin, getOverlap, R=r) #Do the bootstrap. Get some coffee.
overlapMeans = matrix(colMeans(aboot$t),dim(allsets)[1],dim(allsets)[1]) #now average the results across bootstrap samples, and put them back from vector into matrix form.



d_inds = seq(dim(genesets)[1]+1,dim(allsets)[1]) #a list of all indices of drugs
g_inds = seq(1,dim(genesets)[1]) #a list of all indices of genes


#find how many loads on average are in the drugs versus the genes
meanNumDrugLoads = sum(rawOverlapMeans[d_inds,d_inds] * diag(length(d_inds))) / 4
meanNumGeneLoads = mean(c(minNumLoads,maxNumLoads))-meanNumDrugLoads


#get the overlap of the genesets, so we can cancel that out of the co-occurring factors
allsetsM = as.matrix(allsets)
baseSameLoadOverlapScales = (allsetsM %*% t(allsetsM))
numInSet = rowSums(allsets)
baseDiffLoadOverlapScales = (numInSet %*% t(numInSet))
geneoverlapLm = lm(c(overlapMeans[g_inds,g_inds]) ~ c(baseSameLoadOverlapScales) + c(baseDiffLoadOverlapScales))
unexplainedOverlap = matrix(overlapLm$resid,length(g_inds),length(g_inds))
rawOverlapMeans = overlapMeans #unexplainedOverlap is missing drugs, so we're going to put that info into overlapMeans. But first, make a backup copy.
overlapMeans[g_inds,g_inds] = unexplainedOverlap

#look at effect sizes... but using a null of 0, which is not quite right.
overlapEffects = matrix(colMeans(aboot$t) / sqrt(colVars(aboot$t) + 1e-10),dim(allsets)[1],dim(allsets)[1])
overlapEffects[overlapEffects > 10] = 12

#Make two blockwise-constant matrices, the same size as overlaps, so we can normalize the values, so that graphing things will have visible stuff happening in all 4 quadrants.
rescalerMeans = rbind(cbind(matrix(min(overlapMeans[g_inds,g_inds]),
                              dim(genesets)[1],
                              dim(genesets)[1]), 
                       matrix(min(overlapMeans[g_inds,d_inds]),
                              dim(genesets)[1],
                              dim(drugs)[2])),
                 cbind(matrix(min(overlapMeans[d_inds,g_inds]),
                              dim(drugs)[2],
                              dim(genesets)[1]), 
                       matrix(min(overlapMeans[d_inds,d_inds]),
                              dim(drugs)[2],
                              dim(drugs)[2])))
rrange = function(v) {mean(v)-min(v)}
rescalerVar = rbind(cbind(matrix(rrange(overlapMeans[g_inds,g_inds]),
                              dim(genesets)[1],
                              dim(genesets)[1]), 
                       matrix(rrange(overlapMeans[g_inds,d_inds]),
                              dim(genesets)[1],
                              dim(drugs)[2])),
                 cbind(matrix(rrange(overlapMeans[d_inds,g_inds]),
                              dim(drugs)[2],
                              dim(genesets)[1]), 
                       matrix(rrange(overlapMeans[d_inds,d_inds]),
                              dim(drugs)[2],
                              dim(drugs)[2])))

#now do the normalization
rescaled = (overlapMeans - rescalerMeans)/rescalerVar

#find an order so the graph looks pretty. First, just sort by row means, within genes and within drugs
dpermute = d_inds[order(rowMeans(rescaled[d_inds,]))]
gpermute = g_inds[order(rowMeans(rescaled[g_inds,]))]
fullpermute = c(gpermute, dpermute)
sortedOverlaps = rescaled[fullpermute,fullpermute]

#But no, we can do better; hierarchical clusters. A bit slow.
ddist = dist(rescaled[d_inds,], method="euclidean")
dclust = hclust(ddist, method = "average")
gdist = dist(rescaled[g_inds,], method="euclidean")
gclust = hclust(gdist, method = "average")
allclust = c(gclust$order,dclust$order)
sortedOverlaps = rescaled[allclust,allclust]

#graph using pheatmap. SLOW!
#pheatmap(rescaled[allclust,allclust])

#graph using ggplot.
overlapss = melt(sortedOverlaps ^ 0.2)
setnames(overlapss,c("i","j","value"))
ggplot(overlapss, aes(i,j,fill=value)) + geom_raster()

#save our data.
saveRDS(overlapMeans, "overlapMeans.rds")

















#The stuff below is just the simulated data code. I don't think we need it, it was just to explore the packages and see if what we were doing was reasonable. It helped me decide to focus on the first 4 PCA dimensions.

dat = Expr$dat
dat2 = aaply(dat,2,function(v){v[is.na(v)]=mean(v,na.rm=T);return(v)})
ppp = spca(dm,10,1:10)
dm = dat2[1:100,1:1000]

start = Sys.time()
pp = nsprcomp(dm, 10, k=rep(25,10))
print(Sys.time()-start)

nmeans = 5
ncol = 1000
nsigcols = 100
sigoff = 45
sigsize = .4
sigdropoff = 1.3
sigsd = .4
noisesd = 1
means = matrix(0,nmeans,ncol)
for (i in 1:nmeans){
  means[i,(i*sigoff):(i*sigoff+nsigcols-1)]=rnorm(nsigcols,0,sigsize)
}

`%+=%` = function(e1,e2) eval.parent(substitute(e1 <- e1 + e2))
nsimdat=100
simdat = matrix(NA,nsimdat,ncol)
for (i in 1:nsimdat) {
  dat = rnorm(ncol,0,noisesd)
  whichmean = sample(1:nmeans,1,prob=(sigdropoff ^ (-(1:nmeans))))
  dat[(whichmean*sigoff):(whichmean*sigoff+nsigcols-1)] %+=% rnorm(nsigcols,0,sigsd)
  dat %+=% means[whichmean,]
  simdat[i,]=dat
}

pp = nsprcomp(simdat, 10, k=rep(25,10))

for (i in 1:nmeans){
    cat(aaply(pp$rotation, 2, function(x) {sum(x[(i*sigoff):(i*sigoff+nsigcols-1)] != 0)}),"\n")
}
```
